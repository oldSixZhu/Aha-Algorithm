//
//  Tree.c
//  Aha-Algorithm
//
//  Created by Mac on 2017/6/21.
//  Copyright © 2017年 oldSix. All rights reserved.
//

#include <stdio.h>

//满二叉树
//每个结点都有两个儿子
//完全二叉树
//一棵二叉树除了最右边位置上有一个或者几个叶结点缺少外,其他是丰满的,为完全二叉树
//堆
//堆是一种特殊的完全二叉树
//所有父结点比子结点大的为最大堆,所有父结点比子结点小的为最小堆
//创建堆:把n个元素先从左到右从1到n编码,转换成一棵完全二叉树,然后从最后一个非叶结点到根结点,逐个挪动结点,直到成为堆

//最小堆应用
//删除一个数组中最小的数,并增加一个新的数,再次求这个数组中最小的一个数
//相比遍历而言,时间复杂度大大降低,为O(logn)
//插入一个新的元素同理,插在末尾,然后上移,时间复杂度也为O(logn)
void downSmall(){
    //i代表顶点,h数组与n数组长度
    int i=1,h[10],n=10;
    //flag标记是否需要继续向下调整
    int t,flag=0;
    //当i结点有儿子并且需要继续调整的时候,执行循环
    while (i*2<=n && flag==0)
    {
        //首先判断它和左儿子的关系,并用t记录值较小的结点编号
        if (h[i] > h[i*2])
        {
            t = i*2;
        }
        else
        {
            t = i;
        }
        //如果有右儿子,对右儿子进行操作
        if (i*2+1 <= n)
        {
            //如果右儿子值更小,更新小的结点编号
            if (h[t] > h[i*2+1])
            {
                t = i*2+1;
            }
        }
        //如果发现最小的结点编号不是自己,说明子结点中有比父结点更小的
        if (t!=i)
        {
            int temp = h[t];
            h[t] = h[i];
            h[i] = temp;
            //更新i为刚才与它交换的儿子结点的编号,便于向下调整
            i = t;
        }
        //否则说明当前的父结点已经比两个子结点都要小,不需要再进行调整
        else
        {
            flag = 1;
        }
    }
}

//删除最大的元素
int deletemax(){
    //h一个堆,n长度
    int t,h[10],n=10;
    //将堆最后一个点赋值到堆顶
    t = h[1];
    h[1] = h[n];
    //堆的元素减少1
    n--;
    //从顶点向下调整排序
    downSmall();
    return t;
}

//堆排序
//先建立最大堆
void downBig(){
    //i代表顶点,h数组与n数组长度
    int i=1,h[10],n=10;
    //flag标记是否需要继续向下调整
    int t,flag=0;
    //当i结点有儿子并且需要继续调整的时候,执行循环
    while (i*2<=n && flag==0)
    {
        //首先判断它和左儿子的关系,并用t记录值较大的结点编号   //此处不同
        if (h[i] < h[i*2])
        {
            t = i*2;
        }
        else
        {
            t = i;
        }
        //如果有右儿子,对右儿子进行操作
        if (i*2+1 <= n)
        {
            //如果右儿子值更大,更新小的结点编号     此处不同
            if (h[t] < h[i*2+1])
            {
                t = i*2+1;
            }
        }
        //如果发现最大的结点编号不是自己,说明子结点中有比父结点更大的
        if (t!=i)
        {
            int temp = h[t];
            h[t] = h[i];
            h[i] = temp;
            //更新i为刚才与它交换的儿子结点的编号,便于向下调整
            i = t;
        }
        //否则说明当前的父结点已经比两个子结点都要大,不需要再进行调整
        else
        {
            flag = 1;
        }
    }
}
//堆排序
//每次都把堆顶最大值换到末尾,然后排除掉再排序,保持堆顶是最大值
//时间复杂度为O(nlogn)
void duiPaiXu(){
    int h[10],n=10;
    while (n > 1)
    {
        int temp = h[1];
        h[1] = h[n];
        h[n] = temp;
        n--;
        downBig();
    }
}

//像这样支持插入元素和寻找最值的数据结构称为优先队列,堆就是一种优先队列
//普通队列寻找最值需要穷举,而已排序好的数组插入元素需要移动很多
//堆还可以用来求一个数列中第k大的数,要建立一个大小为k的最小堆,从k+1个数开始与堆顶比较,如果比堆顶的数要大,则舍弃当前堆顶将这个数作为堆顶,然后重新排序


//并查集
//并查集通过一个一维数组来实现,本质是维护一个森林,逐渐将树合并成一棵大树,遵循靠左原则和擒贼先擒王原则
//擒贼先擒王原则  递归函数,不停地找根树
int get(int v){
    int f[10]={1,2,3,4,5,6,7,8,9,10};
    if (f[v] == v)
    {
        return v;
    }
    else
    {
        //路径压缩  每次在函数返回的时候,把路上遇到的树的根改为最后找到的根树,可以提高其他树找到根树的速度
        f[v] = get(f[v]);
        return f[v];
    }
}
//合并两子集合的函数
void merge(int v,int u){
    int f[10]={1,2,3,4,5,6,7,8,9,10};
    int t1,t2;
    t1 = get(v);
    t2 = get(u);
    //判断两个结点是否在同一个集合中,即是否为同一个祖先
    if (t1 != t2)
    {
        //靠左原则,左边变成右边的根数,把右边集合作为左边集合的子集合
        f[t2] = t1;
    }
}
void bingChaJi(){
    int i,x,y,m,n,sum=0;
    int f[10]={1,2,3,4,5,6,7,8,9,10};
    scanf("%d %d",&n,&m);
    for (i=1; i<=m; i++)
    {
        //合并树
        scanf("%d %d",&x,&y);
        merge(x,y);
    }
    //最后看有几个树
    for (i=1; i<=n; i++)
    {
        if (f[i]==i)
        {
            sum++;
        }
    }
}



























